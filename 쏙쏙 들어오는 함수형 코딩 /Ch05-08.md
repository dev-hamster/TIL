# Ch05 더 좋은 액션 만들기

## 비즈니스 요구 사항에 맞춰 더 좋은 설계를 하자
- 리팩토링을 통해 좋은 설계를 할 수 있다

리팩토링을 해야할 요소
- 비즈니스 요구사항에 맞지 않는 인자: 요구사항에 족하는 인자를 전달해야함
- 중복된 코드: 코드의 냄새로 향후 문제가 될 수 있음

비즈니스 요구사항에 맞지 않는 인자의 예
```javascript
// Bad 무료 배송 판별을 total과 item_price로 확인
function gets_free_shipping(total, item_price){
  return item_price + total;
}

// Good 무료 배송 판별을 cart에 담긴 아이템으로 확인
function gets_free_shipping(cart){
  var total = 0;
  for(var i = 0; i < cart.length; i++1){
    var item = cart[i];
    total += item.price;
  }
  return total;
}
```

## 의미 있는 걔충울 나눠보기
1. 계산 분류하기: cart에 대한 동작, item에 대한 동작, 비즈니스 규칙으로 분류해보자. 이렇게 그룹화를 하면 계층화할 수 있음
2. 관심사 분리하기:  

결과: 계산과 관심사를 분류해 계층화를 할 수 있음!
- cart에 대한 동작
- item에 대한 동작
- 비즈니스 규칙
- 배열 유틸리티

## 설계란?
엉켜있는 코드를 푸는 것
잘 분리된 코드로 문제를 풀기위해 조합하자

장점:
- 재사용 하기 쉬움
- 유지보수가 좋음
- 테스트하기 쉬움

## Q&A
코드 라인 수와 좋은 코드 연관성
- 라인 수가 짧다고 좋은 코드를 보장하지 않음
- 작은 함수는 이해하기 쉽고, 응집력 있고, 재사용이 좋음

이것도 암묵적 입출력인가?
```javascript
const [count, setCount] = useState(0);

const handleClick = () => {
  setCount(prev => prev+1);
}
```

---
# Ch06 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 카피온 라이트
카피온라이트: 불변성 원칙을 구현함. 따라서 쓰기 동작은 카피온라이트에 따라 구현해야 한다!

카피온라이트 원칙
1. 복사본 만들기
2. 복사본 변경하기
3. 본사본 리턴하기

카피온라이트 특징 
- 카피온 라이트는 쓰기 동작을 읽기로 바꿈
- 데이터를 바꾸지 않고 정보를 리턴했기 때문에 **계산**임 
  - 불변 데이터 구조를 읽는 것은 계산                                                

## 얕은 복사와 깊은 복사
- 옅은 복사: `[{name:'jina', age:3}, ...]` 인 경우 객체는 참조값을 복사. 구조적 공유
- 깊은 복사: 내부의 객체까지 모두 복사

## Q&A
- 133p 예상하기 힘든 병목 지점이 뭐지?
- 함수형 프로그래밍에서 카피온 라이트를 하는 이유?
  - 데이터의 불변성을 위해
  - 불변성을 유지하면 액션이 아닌 계산이 됨

--- 
# Ch07 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

## 방어적 복사
레거시 코드에서 불변성을 유지할 수 있음
> 레거시 코드는 오래전에 만든 것으로 지금 당장 고칠 수 없는 코드

규칙
1. 안전지대로 들어오는 데이터에 깊은 복사를 함
2. 안전진대에서 나가는 데이터에 깊은 복사를 함

안전지대는 카피온라이트 원칙을 적용해 불변성을 보장하는 영역임

특징
- 깊은 복사로 구현하기 때문에 비용이 많이 듦




